js파일 터미널 실행 방법 (노드가 깔려있어야한다.)
  - 터미널 키기
  - 터미널에 node 파일명.js


js 자료형은 typeof()로 알아볼수있다
---------------------------------------------------------------------------------
키입력받기 prompt("입력해주세요") -> 문자열로 반환함 (JAVA의 스캐너역할)
---------------------------------------------------------------------------------
문자열 숫자 형변환 -> parseInt, parseFloat -> 문자열의 시작부터 인식하기 때문에 문자열 시작이 숫자가 아니면 NaN 반환
탈출문자 \
따옴표 표시 -> \' ㅇㅇ \'  역슬래시 표시-> "\\ ㅇㅇㅇ"
---------------------------------------------------------------------------------
++a -> a=a+1 이먼저 실행되고 그값이 나옴
a++ -> a먼저 나오고 그뒤에 계산
---------------------------------------------------------------------------------
Math.pow(2,3); ->>2의3승
Math.sqrt(16); -> 4 제곱근
Math.random(); -> 랜덤수 나오게 0.3534535443534
---------------------------------------------------------------------------------
function sum(arg1, arg2){
	var result = arg1 + arg2
	return result
}
sum(1,2);  => 3
---------------------------------------------------------------------------------
- `==`는  `===` 와 같은 기능을 하는 연산자이나, 사용하지 않는것을 권장합니다.
- `!=`는 `!==` 와 같은 기능을 하는 연산자이나, 사용하지 않는것을 권장합니다.
- 자바스크립트는 **자동 형변환** 기능을 가졌는데, 가볍게 보면 매우 편리한 기능이지만 
알고보면 버그를 만들기 매우 쉬운 위험한 문법으로 받아들여야 합니다.
---------------------------------------------------------------------------------

데이터를 필터링해주는 함수 Array.prototype.filter()

const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];

const result = words.filter(word => word.length > 6);  6글자 이상만

console.log(result);
// expected output: Array ["exuberant", "destruction", "present"]

---------------------------------------------------------------------------------

문자열 붙이기  변수.concat(붙일변수).concat(붙일변수).concat(붙일변수) // 걍 더하기 쓰면댐
특정위치문자열 알아내기 
  - 변수.charAt(0); ,1,2,3 ... // 그냥 인덱스 값 쓰면댐 [0]
  - 변수.substring(2,4); 2번째부터 4번쨰까지 / 변수.substr(2,4); 2번째부터 4개 / 변수.substr(2) 2번째부터 끝까지
  - 변수.indexOf("찾을문자열") -> 문자열위치반환(숫자로)

---------------------------------------------------------------------------------

배열에 객체도 넣을수 있음

배열 추가삭제
  - 배열명.pop -> 맨뒤거 삭제
  - 배열명.shift -> 맨앞에거 삭제
  - 배열명.push -> 맨뒤에 추가
  - 배열명.unshift -> 맨앞에 추가
  - 배열명.reverse -> 큰값부터 정렬
  - 배열명.sort -> 작은값부터 정렬

---------------------------------------------------------------------------------

for in문 (객체의 속성에 접근)
Object.keys(객체명) -> 속성의 이름들이 배열로 나온다.

for in을 쓰면 간단하다

obj 라는 객체가 있다고 가정
for ( let propertyName in obj){
	console.log(propertyName, ":" , obj[propertyName]);
}
obj라는 객체의 속성이름 : 객체명[속성이름의값] 을 반복해서 출력해준다.

---------------------------------------------------------------------------------

변수의  scope 이란?
  - 선언된 변수가 어느위치에서 유효한가를 말한다.

---------------------------------------------------------------------------------

클로저 
  - 함수와 environment로 구성

---------------------------------------------------------------------------------

화살표함수 표현식 (1) : 기본형태
  const sum = function(a, b) {
  return a + b;
};

-->
위의 함수를 아래처럼 간단하게
const sum = (a, b) => {
	return a + b;
};

---------------------------------------------------------------------------------

- 화살표 함수 표현식 (2): `return` 생략 형태
여러 줄의 코드를 포함하고 싶은 경우엔 기본 형태를 사용해야 합니다.

const sum = (a, b) => a + b;

---------------------------------------------------------------------------------

- 화살표 함수 표현식 (3): 인자 괄호 생략 형태
    
    하나의 인자를 입력받는 경우에는 괄호 생략이 가능합니다.

const hello = a => {
	return a;
};
hello('hi'); // hi

---------------------------------------------------------------------------------

5. 익명 함수

- 익명 함수는 일반 함수와 다르게 함수의 이름이 존재하지 않고 변수에 함수를 담아 사용하는 함수입니다.
- 변수에 값을 저장하는 방법처럼 변수에 함수를 저장해서 사용합니다.

    // 일반 함수
    function foo() {
      console.log("bar");
    }
    
    // 익명 함수
    let foo = function () {
      console.log("bar");
    };

익명 함수는 주로 재사용 되지 않고 한번만 사용되는 함수일 경우에 자주 사용하게 되는데, 
이는 일회성인 함수를 일반 함수로 구현 함으로서 불필요한 메모리를 차지하는것을 방지하여 메모리 낭비를 줄일 수 있다는 장점 
때문에 주로 사용됩니다.

하지만 익명 함수 또한 단점이 있는데 밑에서 소개할 Hoisting이 적용되지 않는다는 단점이 있습니다.
일반적으로 작성된 함수의 경우 함수 선언보다 호출이 위에 있더라도 호출하는 위치에 상관없이 사용될 수 있지만, 
익명함수의 경우 Hoisting이 적용되지 않아 에러가 나오게 됩니다.

// 일반 함수로 선언부보다 위에서 함수를 호출했을 때
hello(); // hello!

function hello() {
  console.log("hello!");
}

// 익명 함수의 경우
hello(); // Uncaught ReferenceError: Cannot access 'hello' before initialization (호이스팅이 일어나지 않아서)

const hello = function() {
  console.log("hello!");
}

---------------------------------------------------------------------------------

구조분해할당

구조 분해 할당 문법은 배열혹은 객체에서 각각 값 이나 프로퍼티를 분해하여 손쉽게 개별 변수에 담을 수 있도록 해 줍니다.

배열 에서의 구조 분해 할당
[100,200]이 각각 a 와 b에 담깁니다.

const [a, b] = [100, 200];
console.log(a); // 100
console.log(b); // 200

//혹은 아래와 같이 표현할수있습니다.

const array = [100,200]
const [a,b] = array
console.log(a); //100
console.log(b); //200

// a 에는 array[0] , b에는 array[1] 값이 할당 되었습니다.

객체 에서의 구조 분해 할당
이후에 수업에서 자주 보게 될 객체의 구조 분해 할당입니다.
배열에서의 구조 분해 대상이 배열의 값이 였다면 , 객체에서는 프로포티(property) 가 대상이됩니다.

const student = {
  name: "Sparta",
  age: 18,
  onlineClass: "Node JS",
};
const { name, age, onlineClass } = student
console.log(name); // "Sparta"
console.log(age); // 18
console.log(onlineClass); // "Node JS"

간단 하게 생각해보자면, student라는 객체에서
name, age ,onlineClass등의 property를 쉽게 뽑아서 사용할수있다 라고 생각하시면 될것같습니다.

---------------------------------------------------------------------------------

동기(Sync)와 비동기(Async)에 대한 개념
- 일반적으로 "**동기**로 실행된다" 라고 함은, 먼저 실행된 코드의 결과가 나올때까지 **대기**하는것을 말합니다.
    - **놀이기구**를 생각하면 쉽습니다.
    정원이 30명인 놀이기구가 있다고 가정합니다.
    놀이기구를 한번 태우는데 약 5분이 걸린다고 가정하면 놀이기구를 막 태우기 시작한 시점에서는 대기자 모두 5분이 지나 이미 놀이기구에 탑승했던 사람들이 다 내리기 전까지는 탑승을 할 수 없습니다.
    이것은 **놀이기구 탑승/하차**가 **동기적으로 관리**된다고 볼 수 있습니다.
- 일반적으로 "**비동기**로 실행된다" 라고 함은, **실행된 순서와 관계 없이** 결과가 나오는것을 말합니다.
    - **맛집**을 생각하면 쉽습니다.
    정원이 최대 30명인 **맛집**이 있다고 가정합니다.
    입장 순서는 **선착순**이고 퇴장 순서는 **다 먹은 사람**이 바로 나올 수 있습니다. 다 먹은 사람이 나오면 나온 사람 수 만큼 다시 입장 할 수 있습니다. 사람마다 먹는 시간은 모두 다릅니다.
    이것은 **입/퇴장**이 **비동기적**으로 처리된다고 볼 수 있습니다.

---------------------------------------------------------------------------------

Blocking Model & Non-Blocking Model
- **Blocking Model**이란, 코드의 실행이 끝나기 전까지 **실행 제어권을 다른곳에 넘기지 않아 다른 작업을 하지 못하고 대기**하는 것을 말합니다.
- **Non-blocking Model**이란, 코드의 실행이 끝나지 않아도 **실행 제어권을 다른곳에 넘겨 다음 코드가 실행**될 수 있는것을 말합니다.
- 동기, 비동기와 뭐가 다른걸까?
    - **제어권을 넘기면(Non-blocking)** 다른 코드도 실행될 수 있으므로 **비동기 처리가 가능**하지만 **제어권을 넘기지 않으면(Blocking)** 비동기 처리가 가능한 환경이어도 **비동기 처리가 불가능**합니다.
- 자바스크립트는 **Async + Non-blocking Model**을 채용하여 **현재 실행중인 코드의 실행이 끝나지 않아도 다음 코드를 호출**합니다.
- 결론적으로 자바스크립트는 **Non-blocking Model**을 가지며 각 명령이 순서대로 실행될 수 있게 구현되어 있지만, **Non-blocking Model**에 의해 명령이 아닌 **모든 함수는 비동기적으로 실행**됩니다.

예시 (setTimeout은 특정 시간 뒤에 함수를 실행해주는 역할입니다.)

function first() {
  console.log('First');
}

setTimeout(first, 1000); // 1000ms(1초) 뒤에 first 함수를 실행해준다.

console.log('Middle');
console.log('Last');

// Print: Middle
// Last
// First

만약 자바스크립트가 Non-blocking Model이 아니었다면 위 코드는 1초를 기다려서 first 함수를 먼저 호출하여 'First'를 출력한 뒤, 
'Middle', 'Last' 순서로 출력해야 합니다.

---------------------------------------------------------------------------------

Promise

- 자바스크립트에서 **비동기 처리**를 **동기**로 처리할 수 있게 돕는 객체 유형입니다.
이 객체를 이용하면 여러분은 **Non-blocking Model**을 가진 자바스크립트에서도 비동기 처리를 아주 손쉽게 할 수 있습니다.
- Promise 생성자 인터페이스
`executor`에는 함수만 올 수 있으며 인자로 `resolve`, `reject`가 주입됩니다.

new Promise(executor);

// 예제
new Promise((resolve, reject) => {
	// 명령문
});

- 프로미스의 상태
    프로미스는 반드시 3가지 상태를 지니며, **대기(Pending)** 상태가 아니라면 Promise의 연산이 이미 끝난 상태로 볼 수 있습니다.
    - 대기(*Pending)*: 이행하거나 거부되지 않은 초기 상태.
    - 이행(*Fulfilled)*: 연산이 성공적으로 완료됨.
    - 거부(*Rejected)*: 연산이 실패함.

- 프로미스가 만들어 질 때 `executor`가 실행되며, `executor`에서 `resolve` 함수가 호출되기 전까지 `firstPromise.then(...)` 안에 있는
 코드를 실행하지 않습니다.

---------------------------------------------------------------------------------

비동기 함수 (Async Function)
- 특징
    비동기 함수는 일반 함수나 화살표 함수와 아주 비슷하지만 딱 두가지만 다릅니다.
    
    1. **비동기 함수**의 **결과 값**은 **항상 Promise** 객체로 `resolve`된다.
    2. **비동기 함수** **안에서만** `await` 연산자를 사용할 수 있다. (바로 아래에서 배웁니다!)
    
    이 두가지 특징을 제외하면 기존처럼 일반 함수나, 화살표 함수처럼 사용할 수 있습니다. 아래처럼요.
    아래 세가지 함수 모두 결과 값은 Promise로 받습니다.

// 비동기 + 일반 함수
async function 함수이름() {
	// 명령문
}

// 비동기 + 익명 함수
async function() {
  // 명령문
}

// 비동기 + 화살표 함수
async () => {
	// 명령문
}

이러한 특징은 마치 아래처럼 작성하는것과 굉장히 비슷합니다.

function 함수이름() {
	return Promise.resolve('값');
}

// 위와 아래의 함수는 같은 동작을 보여준다.

async function 함수이름2() {
	return '값';
}

함수이름();
// Print: Promise { '값' }

함수이름2();
// Print: Promise { '값' }

- 그럼 비동기 함수는 왜 쓸까요?
아래에서 배울 `await` 연산자를 비동기 함수 안에서만 사용할 수 있는데요, 이를 활용하면 문법이 훨씬 간결해질 수 있습니다.
덕분에 비동기 함수는 여러분이 비동기 프로그래밍을 하게 되면 즐겨 사용하는 함수 유형중 하나가 될 것 입니다
- `new Promise(executor)` 코드로 Promise를 직접 생성하면 `executor`가 바로 실행되는것과 달리, **비동기 함수**는 **함수가
 실행되기 전까지 Promise를 생성하지 않습니다.**

 Callback, Event loop, Call stack에 대해 알아보시는것이 좋습니다.

---------------------------------------------------------------------------------

await 연산자
- `await` 연산자를 사용하면 **Promise**가 **fulfill**되거나 **rejected**될 때 까지 **함수의 실행을 중단**하고 기다릴 수 있습니다.
**Promise**의 연산이 끝나면 함수에서 **반환한 값을 얻을 수 있습니다.**
- **await 연산자는 async 함수 안에서만 사용할 수 있습니다.**
- 인터페이스
const result = await 값;

"값" 에는 Promise가 아닌 다른 값도 들어갈 수 있습니다. 아래처럼요!
Promise가 아니라면 기다리지 않고 해당 값 자체를 그대로 반환합니다.
async function 함수이름() {
	const result = await 'Test!';
	console.log(result);
}

함수이름();
// Print: 'Test!';

---------------------------------------------------------------------------------




